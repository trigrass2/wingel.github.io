---
layout: post
title: Halloween Milling
date: '2013-11-18T02:41:00.000+01:00'
author: Christer Weinigel
tags: 
modified_time: '2013-11-18T02:41:19.758+01:00'
thumbnail: http://4.bp.blogspot.com/-q7JgMyoxN_4/Uolu1rDprrI/AAAAAAAAAI4/dK67iQdfCmc/s72-c/x-pcb.jpg
blogger_id: tag:blogger.com,1999:blog-4618495377058807667.post-427762470802484282
permalink: /2013/11/halloween-milling.html
---

A few years ago I bought a cheap CNC mill from China.  It's actually a "CNC engraving machine", but it's actually robust enough so that it can mill wood and soft metals such as aluminum.  á¸®'ve been using it to build electronics prototypes, both for milling PCBs and for milling enclosures.<br /><br />To control the CNC mill I have been using <a href="http://www.linuxcnc.org/">LinuxCNC (formerly known as EMC2)</a>. LinuxCNC takes a toolpath written in <a href="http://en.wikipedia.org/wiki/G-code">G-code</a> which says how the milling tool should move, and translates those into the electronic signals that drive the motors on the mill.<br /><br />For PCB milling I've been using a tool called <a href="http://sourceforge.net/apps/mediawiki/pcb2gcode">pcb2gcode</a>which takes gerber files produced by a PCB CAD program such as <a href="http://www.cadsoftusa.com/">Eagle</a> and produces G-code.  It works really well and makes it possible to quickly testing simple electronic designs.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://4.bp.blogspot.com/-q7JgMyoxN_4/Uolu1rDprrI/AAAAAAAAAI4/dK67iQdfCmc/s1600/x-pcb.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="240" src="http://4.bp.blogspot.com/-q7JgMyoxN_4/Uolu1rDprrI/AAAAAAAAAI4/dK67iQdfCmc/s320/x-pcb.jpg" width="320" /></a></div><br /><br />For enclosures I have mostly been bying ready-made enclosures and then written a bit of G-code by hand to mill holes in them.  I've also been milling wood and plastics for simple stuff such as this lid.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-53KeKsdsXWY/Uolu7KnSKBI/AAAAAAAAAJA/j9gCVI_P7Os/s1600/x-lid.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="240" src="http://3.bp.blogspot.com/-53KeKsdsXWY/Uolu7KnSKBI/AAAAAAAAAJA/j9gCVI_P7Os/s320/x-lid.jpg" width="320" /></a></div><br /><br />Writinga G-code by hand is a very tedious job, anything more complicated than a few holes requires a lot of work.  There are a lot of tools and meta-languages for generating G-code from other languages.  I wrote my own little Python library for generating G-code and it turns out that the Axis GUI for LinuxCNC can actually load and run Python programs and execute the G-codes that are printed by the program.  But even with all these tools or meta-languages it's still quite tedious to generate the toolpaths by hand.<br /><br />It would be even nicer if there was a way to create a 3D model in a tool such as <a href="http://www.openscad.org/">OpenSCAD</a> or <a href="http://www.blender.org/">Blender</a> and then magically let a tool generate G-code, a toolpath which tells the mill how the tool should move to create a physical object which looks like the model. Most 3D modeling tools can export to a standardised interchange format called <a href="http://en.wikipedia.org/wiki/STL_(file_format)">STL</a> and there are lots of tools which can read STL and generate toolpaths.<br /><br />Most of these tools are proprietary though and the cost ranges from expensive to insanely expensive.  Most of them only run on Windows and I prefer to use Linux and anyway I like open source, so I would prefer to use an open source toolpath generator if possible.  There are a bunch of those, but most are at the "alpha" level and nowhere close to being usable.  The most mature open source toolpath generator I have found is <a href="http://pycam.sourceforge.net/">PyCAM</a>. Unfortunately PyCAM and I don't really get along, I don't like the toolpaths it generates and last time I tried, it was really, really slow.  My guess is that one for PyCAM being so slow is that it tries to be very generic and handle models and milling tools of almost any shape.  Algorithms to calculate a toolpath for an abitrary 3D shape around an arbitrary 3D model are complex and expensive.<br /><br />For a long time there have been this thoght at the back of my head that "there must be an easier way".  For almost everything I want to mill, I'm going to use a cylindrical tool.  With a cylindrical milling tool, the toolpath generation problem is reduced to 2.5D, that is, for each position X and Y the tool is allowed to reach a certain depth Z. This 2.D problem ought to be a lot easier to solve than the generic 3D problem.<br /><br />A fairly simple strategy of milling 2.5D shapes would be to slice up the 3D model into 2D layers.  The algorithm would then start from the top, and remove material for each 2D layer until there is no more material to remove.  This is called waterline machining.  It might not be the fastest way to things, but it should be fairly foolproof.<br /><br />For removing material there are lots of ways to do it.  The simplest way is to just move back and forth in a zig-zag pattern.  But there are much better ways to do it, to reduce the wear on the milling tool it's preferable to keep a constant load on the tool, i.e. cut with the same side of the tool at the same depth and at the same speed all the time.  The most important thing is to avoid is rapid load changes such as cutting 90 degrees into a wal.  This <a href="http://bobcad.com/cad-cam-software-high-speed-machining/">article att BobCAD-CAM</a> shows some of the toolpah options that used. Option 3, the High Speed Machining (HSM) toolpath, is the best since it avoids any sharp corners and each cut is very smooth.<br /><br />I have been toying with algorithms like these for a few years but have never gotten anywhere.  But a few weeks ago just before Halloween I tried a slightly different approach.  The goal was to find an algorithm which would remove material from a 2D outline and do it using the same side of the tool to perform all cuts and which would try to keep the cuts at a constant width.<br /><br />What I did was to split the toolpath generation into four steps.<br /><br />1. Take the model and shrink it by the milling tool radius.  This way the algorithm can ignore the tool with for the rest of the calculations, instead it only have think about where the tool can move.<br /><br />2. Find the center of largest circle that can be inscribed in the model.  To do this just shrink the model until there is nothing left and use the center of the last polygon as the starting point.<br /><br />3. Start cutting a spiral from the starting point outwards until the spiral intersects the outline.  For each 360 degree turn the radius of the spiral grows by the cut width.<br /><br />4. Cut away the rest of the material.  Start by creating a polygon with the the material that has already been cut away, this will roughly be the convex hull of the spiral.  Grow the polygon by the cut width and then clip it with the model.  The difference between the polygon of already removed material and the grown and clipped polygon are a number of polygons with material that is possible to remove. Choose one of them, mill away the material, add the polygon of just removed material to the big polygon of removed material and start over again until there is no more material to remove.<br /><br />I started out by using <a href="http://www.angusj.com/delphi/clipper.php">the Python port of the Clipper library</a> to do the shrinking, growing and clipping but switched to <a href="https://pypi.python.org/pypi/Shapely">Shapely</a>after a while because I needed some function that wasn't available in Clipper.  A function that I ended up not using in the end anyway, but by then I couldn't be bothered to switch back.<br /><br />This actually turned out to work quite well.  Because it was Halloween I decided to do a small test with a <a href="http://free.clipartof.com/details/118-Witch-Flying-Silhouette-Free-Hallow/een-Vector-Clipart-Illustration">witch silhouette</a> I found.  I converted it by hand from SVG to a bunch of coordinates (and managed to flip the image horizontally and lose a few parts of the broom on the way).<br /><br />The following video shows the algorithm running.<br /><br /><div class="separator" style="clear: both; text-align: center;"><object width="320" height="266" class="BLOG_video_class" id="BLOG_video-12bdfbf56f1eea8a" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0"><param name="movie" value="//www.youtube.com/get_player"><param name="bgcolor" value="#FFFFFF"><param name="allowfullscreen" value="true"><param name="flashvars" value="flvurl=http://redirector.googlevideo.com/videoplayback?id%3D12bdfbf56f1eea8a%26itag%3D5%26source%3Dblogger%26app%3Dblogger%26cmo%3Dsensitive_content%253Dyes%26ip%3D0.0.0.0%26ipbits%3D0%26expire%3D1451936976%26sparams%3Did,itag,source,ip,ipbits,expire%26signature%3D19E2DEB3A2D1F59F39AD9041C09DCB1E834EC7C.7B7BFF3A67ABA2D5C7F1F9756D8DB10D97CDC158%26key%3Dck2&amp;iurl=http://video.google.com/ThumbnailServer2?app%3Dblogger%26contentid%3D12bdfbf56f1eea8a%26offsetms%3D5000%26itag%3Dw160%26sigh%3DNgtEma57ff4ema7mYTm-97vjY6A&amp;autoplay=0&amp;ps=blogger"><embed src="//www.youtube.com/get_player" type="application/x-shockwave-flash" width="320" height="266" bgcolor="#FFFFFF" flashvars="flvurl=http://redirector.googlevideo.com/videoplayback?id%3D12bdfbf56f1eea8a%26itag%3D5%26source%3Dblogger%26app%3Dblogger%26cmo%3Dsensitive_content%253Dyes%26ip%3D0.0.0.0%26ipbits%3D0%26expire%3D1451936976%26sparams%3Did,itag,source,ip,ipbits,expire%26signature%3D19E2DEB3A2D1F59F39AD9041C09DCB1E834EC7C.7B7BFF3A67ABA2D5C7F1F9756D8DB10D97CDC158%26key%3Dck2&iurl=http://video.google.com/ThumbnailServer2?app%3Dblogger%26contentid%3D12bdfbf56f1eea8a%26offsetms%3D5000%26itag%3Dw160%26sigh%3DNgtEma57ff4ema7mYTm-97vjY6A&autoplay=0&ps=blogger" allowFullScreen="true" /></object></div><br />Since this seemed to work so well I quickly added some functions to generate G-code and then used LinuxCNC to run the G-code on the mill. And what do you know, it actually worked quite well.<br /><br /><div class="separator" style="clear: both; text-align: center;"><object width="320" height="266" class="BLOG_video_class" id="BLOG_video-5b514b753d0febfd" classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0"><param name="movie" value="//www.youtube.com/get_player"><param name="bgcolor" value="#FFFFFF"><param name="allowfullscreen" value="true"><param name="flashvars" value="flvurl=http://redirector.googlevideo.com/videoplayback?id%3D5b514b753d0febfd%26itag%3D5%26source%3Dblogger%26app%3Dblogger%26cmo%3Dsensitive_content%253Dyes%26ip%3D0.0.0.0%26ipbits%3D0%26expire%3D1451936976%26sparams%3Did,itag,source,ip,ipbits,expire%26signature%3DF881BD3A7C4BB86DF4F6C48C5809641A2043F95.3B185607C9C9080EEC4F1A7A3AB011961AFB343%26key%3Dck2&amp;iurl=http://video.google.com/ThumbnailServer2?app%3Dblogger%26contentid%3D5b514b753d0febfd%26offsetms%3D5000%26itag%3Dw160%26sigh%3DoF-FKSPqhUc8NOErc9jJQ9OHbe4&amp;autoplay=0&amp;ps=blogger"><embed src="//www.youtube.com/get_player" type="application/x-shockwave-flash" width="320" height="266" bgcolor="#FFFFFF" flashvars="flvurl=http://redirector.googlevideo.com/videoplayback?id%3D5b514b753d0febfd%26itag%3D5%26source%3Dblogger%26app%3Dblogger%26cmo%3Dsensitive_content%253Dyes%26ip%3D0.0.0.0%26ipbits%3D0%26expire%3D1451936976%26sparams%3Did,itag,source,ip,ipbits,expire%26signature%3DF881BD3A7C4BB86DF4F6C48C5809641A2043F95.3B185607C9C9080EEC4F1A7A3AB011961AFB343%26key%3Dck2&iurl=http://video.google.com/ThumbnailServer2?app%3Dblogger%26contentid%3D5b514b753d0febfd%26offsetms%3D5000%26itag%3Dw160%26sigh%3DoF-FKSPqhUc8NOErc9jJQ9OHbe4&autoplay=0&ps=blogger" allowFullScreen="true" /></object></div><br />The video is speeded up 10 times, in real life it took about 20 minutes to run. &nbsp;The algorithm video and the actual milling video differ a bit in the cuts since I tweaked the algorithm slightly in between.<br /><br />Of course this is just a quick proof of concept hack to see if the algorithm would work at fall, but it does look rather promising.<br /><br />There are lots of things to do though to bang this into shape so that it is actually useful.<br /><br />The algorithm makes a few mistakes where removes too much material at the same time.  It really should try to find a way of smoothly moving into each cut.<br /><br />The algorithm does not support multiple pockets or pockets with holes.<br /><br />The algorithm only cuts one layer in 2D, to be useful for milling it needs to be extended to 2.5D.<br /><br />Yet another pre alpha not even close to production ready piece of software for generating toolpaths.  Probably not that interesting, but if anyone wants to see the source code, drop me a line. 